{% extends "base.html" %}

{% block title %}Dashboard - IFI Essay Gateway{% endblock %}

{% block content %}
<div class="mb-4">
    <h1 class="h2">üìù IFI Essay Gateway</h1>
    <p class="text-muted">Clearing the way so every fatherhood story is heard.</p>
    <p>Welcome to IFI Essay Gateway. This tool helps teachers organize essay entries, so more time can be spent reading students' stories about what their fathers and father‚Äëfigures mean to them. It automatically gathers basic information from the official entry forms and sorts essays by grade level, while keeping each student's words exactly as they wrote them.</p>
</div>


<div class="card">
    <div class="card-header">
        <h3 class="h5 mb-0">1Ô∏è‚É£ Upload Entry Forms</h3>
    </div>
    <div class="card-body">
        <form method="POST" action="{{ url_for('upload') }}" enctype="multipart/form-data">
            <div class="mb-3">
                <label class="form-label"><strong>üì§ Upload Mode:</strong></label>
                <div class="btn-group w-100" role="group">
                    <input type="radio" class="btn-check" name="upload_mode" id="single" value="single">
                    <label class="btn btn-outline-primary" for="single">Single Entry</label>
                    
                    <input type="radio" class="btn-check" name="upload_mode" id="multiple" value="multiple" checked>
                    <label class="btn btn-outline-primary" for="multiple">Multiple Entries</label>
                </div>
            </div>

            <div class="mb-3">
                <label for="files" class="form-label">Choose entry form(s)</label>
                <input type="file" class="form-control" id="files" name="files" 
                       accept=".png,.jpg,.jpeg,.pdf" multiple>
                <div class="form-text">Upload IFI essay contest entry form(s) (PNG, JPG, or PDF)</div>
            </div>
            
            <!-- Selected Files List -->
            <div id="selectedFilesList" class="mb-3" style="display: none;">
                <label class="form-label"><strong>Selected Files:</strong></label>
                <div id="filesList" class="list-group">
                    <!-- Files will be added here dynamically -->
                </div>
            </div>

            <button type="submit" class="btn btn-primary btn-lg" id="processBtn">
                <i class="bi bi-upload"></i> <span id="btnText">Process Entries</span>
                <span id="btnSpinner" class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
            </button>
        </form>
        
        <!-- Loading Overlay -->
        <div id="loadingOverlay" class="d-none" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 9999; display: flex; align-items: center; justify-content: center;">
            <div class="card" style="max-width: 600px; margin: 20px; background: white;">
                <div class="card-body text-center p-5">
                    <div class="spinner-border text-primary mb-3" role="status" style="width: 3rem; height: 3rem;">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <h5 class="card-title">Processing Submissions</h5>
                    <p class="card-text" id="loadingMessage">Please wait while we process your files...</p>
                    <div class="progress mt-3" style="height: 30px;">
                        <div class="progress-bar progress-bar-striped progress-bar-animated" 
                             role="progressbar" 
                             style="width: 0%" 
                             id="progressBar"
                             aria-valuenow="0" 
                             aria-valuemin="0" 
                             aria-valuemax="100">
                            <span id="progressText">0%</span>
                        </div>
                    </div>
                    <div class="mt-3">
                        <small class="text-muted">
                            <span id="completedCount">0</span> of <span id="totalCount">0</span> files processed
                        </small>
                    </div>
                    <div class="mt-2">
                        <small class="text-info" id="timeEstimate">Estimating time...</small>
                    </div>
                </div>
            </div>
        </div>

        <!-- Processing started ‚Äì email notification modal -->
        <div class="modal fade" id="processingStartedModal" tabindex="-1" aria-labelledby="processingStartedModalLabel" aria-hidden="true" data-bs-backdrop="static">
            <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header border-0 pb-0">
                        <h5 class="modal-title" id="processingStartedModalLabel">Essays submitted</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body text-center py-4">
                        <p class="mb-0" id="processingStartedPrimaryMessage">Essays are processing and an email will be sent once they are done.</p>
                        <p class="text-muted small mt-2 mb-0">You can leave this page; processing continues in the background.</p>
                        <div id="processingDuplicateNotice" class="alert alert-warning mt-3 mb-0 d-none" role="alert"></div>
                    </div>
                    <div class="modal-footer border-0 justify-content-center">
                        <button type="button" class="btn btn-primary" id="processingStartedDismissBtn" data-bs-dismiss="modal">OK</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Upload error modal (e.g. queue unavailable) ‚Äì show message, click OK to dismiss -->
        <div class="modal fade" id="uploadErrorModal" tabindex="-1" aria-labelledby="uploadErrorModalLabel" aria-hidden="true" data-bs-backdrop="static">
            <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header border-0 pb-0">
                        <h5 class="modal-title" id="uploadErrorModalLabel">Could not start processing</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body text-center py-4">
                        <p class="mb-0" id="uploadErrorModalMessage">Something went wrong. Please try again.</p>
                    </div>
                    <div class="modal-footer border-0 justify-content-center">
                        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Duplicate Scan Modal -->
        <div class="modal fade" id="duplicateModal" tabindex="-1" aria-labelledby="duplicateModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="duplicateModalLabel">Duplicates Detected</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <p class="text-muted mb-3" id="duplicateSummary"></p>
                        <div class="list-group" id="duplicateList"></div>
                        <div class="form-text mt-2">
                            By default, duplicate files are skipped. Check any duplicate you want to reprocess.
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-outline-secondary" id="duplicateCancelBtn" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" id="duplicateConfirmBtn">Upload Selected</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

{% if session.upload_results %}
<div class="card">
    <div class="card-header d-flex justify-content-between align-items-center">
        <h3 class="h5 mb-0">üìä Processing Results</h3>
        <form method="POST" action="{{ url_for('clear_results') }}" style="display: inline;">
            <button type="submit" class="btn btn-sm btn-outline-secondary">
                <i class="bi bi-x-circle"></i> Dismiss
            </button>
        </form>
    </div>
    <div class="card-body">
        {% for result in session.upload_results %}
        <div class="alert alert-{{ 'success' if result.status == 'success' else 'danger' }}">
            <strong>{{ result.filename }}</strong>
            {% if result.status == 'success' %}
                <br>‚úÖ Successfully processed (ID: {{ result.submission_id }})
            {% else %}
                <br>‚ùå Error: {{ result.error }}
            {% endif %}
        </div>
        {% endfor %}
    </div>
</div>
{% endif %}

<div class="row">
    <div class="col-md-4">
        <div class="card">
            <div class="card-body text-center">
                <h3 class="h2" id="dbStatsTotal">{{ db_stats.total_count }}</h3>
                <p class="text-muted mb-0">Total Records</p>
            </div>
        </div>
    </div>
    <div class="col-md-4">
        <div class="card">
            <div class="card-body text-center">
                <h3 class="h2 text-success" id="dbStatsClean">{{ db_stats.clean_count }}</h3>
                <p class="text-muted mb-0">Clean Records</p>
            </div>
        </div>
    </div>
    <div class="col-md-4">
        <div class="card">
            <div class="card-body text-center">
                <h3 class="h2 text-warning" id="dbStatsNeedsReview">{{ db_stats.needs_review_count }}</h3>
                <p class="text-muted mb-0">Needs Review</p>
            </div>
        </div>
    </div>
</div>

<div class="mt-4 text-center text-muted small">
    <p>üí° IFI Essay Gateway is an internal intake and review assistant that helps manage thousands of student essays submitted each year for the Illinois Fatherhood Initiative's fatherhood essay contest.</p>
</div>
{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const form = document.querySelector('form[action="{{ url_for('upload') }}"]');
    const processBtn = document.getElementById('processBtn');
    const btnText = document.getElementById('btnText');
    const btnSpinner = document.getElementById('btnSpinner');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const loadingMessage = document.getElementById('loadingMessage');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const completedCount = document.getElementById('completedCount');
    const totalCount = document.getElementById('totalCount');
    const timeEstimate = document.getElementById('timeEstimate');
    const filesInput = document.getElementById('files');
    const selectedFilesList = document.getElementById('selectedFilesList');
    const filesList = document.getElementById('filesList');
    const duplicateModalEl = document.getElementById('duplicateModal');
    const duplicateList = document.getElementById('duplicateList');
    const duplicateSummary = document.getElementById('duplicateSummary');
    const duplicateConfirmBtn = document.getElementById('duplicateConfirmBtn');
    const duplicateCancelBtn = document.getElementById('duplicateCancelBtn');
    const duplicateModal = duplicateModalEl ? new bootstrap.Modal(duplicateModalEl) : null;
    const processingStartedEl = document.getElementById('processingStartedModal');
    const processingDuplicateNotice = document.getElementById('processingDuplicateNotice');
    const processingStartedPrimaryMessage = document.getElementById('processingStartedPrimaryMessage');
    
    if (processingStartedEl) {
        processingStartedEl.addEventListener('hidden.bs.modal', function() {
            if (processingDuplicateNotice) {
                processingDuplicateNotice.classList.add('d-none');
                processingDuplicateNotice.textContent = '';
            }
            if (processingStartedPrimaryMessage) {
                processingStartedPrimaryMessage.textContent = 'Essays are processing and an email will be sent once they are done.';
            }
            selectedFiles = [];
            updateFilesList();
            if (filesInput) filesInput.value = '';
            resetSubmitButton();
            fetch('/api/clear_jobs', { method: 'POST' }).catch(err => console.error('Error clearing jobs:', err));
        });
    }

    function showUploadErrorModal(message) {
        const msgEl = document.getElementById('uploadErrorModalMessage');
        if (msgEl) msgEl.textContent = message;
        const el = document.getElementById('uploadErrorModal');
        if (el) bootstrap.Modal.getOrCreateInstance(el).show();
    }

    const uploadErrorEl = document.getElementById('uploadErrorModal');
    if (uploadErrorEl) {
        uploadErrorEl.addEventListener('hidden.bs.modal', function() {
            selectedFiles = [];
            updateFilesList();
            if (filesInput) filesInput.value = '';
            resetSubmitButton();
        });
    }
    
    if (!filesInput) {
        console.error('File input element not found!');
    }
    if (!selectedFilesList) {
        console.error('Selected files list element not found!');
    }
    if (!filesList) {
        console.error('Files list element not found!');
    }
    
    let pollInterval = null;
    let startTime = null;
    let selectedFiles = []; // Array to store File objects
    let lastScanResults = [];
    let pendingDuplicateNotice = '';
    let uiInteractionLocked = false;
    
    // Function to update the selected files display
    function updateFilesList() {
        console.log('updateFilesList called. selectedFiles.length:', selectedFiles.length);
        
        if (selectedFiles.length === 0) {
            selectedFilesList.style.display = 'none';
            filesList.innerHTML = '';
            processBtn.disabled = true;
        } else {
            selectedFilesList.style.display = 'block';
            filesList.innerHTML = '';
            processBtn.disabled = false;
            
            selectedFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'list-group-item d-flex justify-content-between align-items-center';
                
                // Determine icon based on file extension
                const ext = file.name.split('.').pop().toLowerCase();
                let iconClass = 'bi-file-pdf text-danger';
                if (['png', 'jpg', 'jpeg'].includes(ext)) {
                    iconClass = 'bi-file-image text-primary';
                }
                
                fileItem.innerHTML = `
                    <div class="d-flex align-items-center">
                        <i class="bi ${iconClass} me-2"></i>
                        <span>${file.name}</span>
                        <small class="text-muted ms-2">(${(file.size / 1024).toFixed(1)} KB)</small>
                    </div>
                    <button type="button" class="btn btn-sm btn-outline-danger remove-file-btn" onclick="removeFile(${index})">
                        <i class="bi bi-x-circle"></i> Remove
                    </button>
                `;
                filesList.appendChild(fileItem);
            });
            
            console.log('Files list updated. Displayed', selectedFiles.length, 'files');
        }
        applyInteractionLockState();
    }
    
    // Function to remove a file from the selection
    window.removeFile = function(index) {
        console.log('Removing file at index:', index);
        if (index >= 0 && index < selectedFiles.length) {
            selectedFiles.splice(index, 1);
            console.log('Remaining files:', selectedFiles.length);
            updateFilesList();
        }
    };
    
    // Handle file input change
    if (filesInput) {
        filesInput.addEventListener('change', function(e) {
            console.log('File input change event fired!');
            console.log('Event target:', e.target);
            console.log('Files:', e.target.files);
            console.log('Files length:', e.target.files ? e.target.files.length : 0);
            
            if (!e.target.files || e.target.files.length === 0) {
                console.log('No files selected or user cancelled');
                return; // User cancelled file selection
            }
            
            const newFiles = Array.from(e.target.files);
            console.log('New files array:', newFiles);
            console.log('New files count:', newFiles.length);
            
            // Check upload mode - default to 'multiple' if not found
            const uploadModeRadio = document.querySelector('input[name="upload_mode"]:checked');
            const uploadMode = uploadModeRadio ? uploadModeRadio.value : 'multiple';
            console.log('Upload mode:', uploadMode);
            
            if (uploadMode === 'single') {
                // Single mode: replace existing files with the new selection
                selectedFiles = newFiles.slice(0, 1); // Only take the first file
                console.log('Single mode: selected', selectedFiles.length, 'file');
                console.log('Selected file:', selectedFiles[0] ? selectedFiles[0].name : 'none');
            } else {
                // Multiple mode: add new files to existing selection (avoid duplicates)
                let addedCount = 0;
                newFiles.forEach((newFile, idx) => {
                    console.log(`Processing file ${idx + 1}:`, newFile.name, newFile.size, 'bytes');
                    // Check if file already exists (by name and size)
                    const exists = selectedFiles.some(f => 
                        f.name === newFile.name && 
                        f.size === newFile.size &&
                        f.lastModified === newFile.lastModified
                    );
                    if (!exists) {
                        selectedFiles.push(newFile);
                        addedCount++;
                        console.log('Added file:', newFile.name);
                    } else {
                        console.log('Skipped duplicate:', newFile.name);
                    }
                });
                console.log('Multiple mode: added', addedCount, 'new files. Total:', selectedFiles.length);
            }
            
            // Clear the file input to allow selecting the same files again if needed
            // We'll use selectedFiles array for submission, not the input
            this.value = '';
            
            // Update the display
            console.log('Calling updateFilesList with', selectedFiles.length, 'files');
            updateFilesList();
        });
        
        console.log('File input change listener attached');
    } else {
        console.error('Cannot attach file input listener - filesInput is null');
    }
    
    // Handle upload mode change
    document.querySelectorAll('input[name="upload_mode"]').forEach(radio => {
        radio.addEventListener('change', function(e) {
            const mode = e.target.value;
            
            if (mode === 'single' && selectedFiles.length > 1) {
                // Switch to single mode: keep only the first file
                selectedFiles = selectedFiles.slice(0, 1);
                
                // Update the file input
                const dataTransfer = new DataTransfer();
                if (selectedFiles.length > 0) {
                    dataTransfer.items.add(selectedFiles[0]);
                }
                filesInput.files = dataTransfer.files;
                
                updateFilesList();
            }
            // If switching to multiple mode, no need to change anything
        });
    });
    
    function formatTime(seconds) {
        if (seconds < 60) {
            return `${Math.ceil(seconds)} seconds`;
        } else {
            const mins = Math.floor(seconds / 60);
            const secs = Math.ceil(seconds % 60);
            return `${mins}m ${secs}s`;
        }
    }
    
    // Track if we've already shown success for current batch
    let successShownForBatch = false;

    function resetSubmitButton() {
        if (processBtn) processBtn.disabled = false;
        if (btnText) btnText.textContent = 'Process Entries';
        if (btnSpinner) btnSpinner.classList.add('d-none');
    }

    function applyInteractionLockState() {
        if (filesInput) filesInput.disabled = uiInteractionLocked;
        document.querySelectorAll('input[name="upload_mode"]').forEach(radio => {
            radio.disabled = uiInteractionLocked;
        });
        document.querySelectorAll('.remove-file-btn').forEach(btn => {
            btn.disabled = uiInteractionLocked;
        });
        if (processBtn && uiInteractionLocked) processBtn.disabled = true;
    }

    function setInteractionLock(locked, message = 'Checking for duplicates...') {
        uiInteractionLocked = locked;
        applyInteractionLockState();

        // Reuse the full-screen overlay to prevent page interactions during preflight.
        if (loadingOverlay) {
            if (locked) {
                if (loadingMessage) loadingMessage.textContent = message;
                if (timeEstimate) timeEstimate.textContent = '';
                if (totalCount) totalCount.textContent = selectedFiles.length.toString();
                if (completedCount) completedCount.textContent = '0';
                if (progressBar) {
                    progressBar.style.width = '0%';
                    progressBar.setAttribute('aria-valuenow', '0');
                }
                if (progressText) progressText.textContent = '0%';
                loadingOverlay.classList.remove('d-none');
                loadingOverlay.style.display = 'flex';
            } else {
                loadingOverlay.classList.add('d-none');
                loadingOverlay.style.display = 'none';
            }
        }
    }

    function showProcessingDuplicateNotice(message) {
        if (!processingDuplicateNotice) return;
        if (message && message.trim().length > 0) {
            processingDuplicateNotice.textContent = message;
            processingDuplicateNotice.classList.remove('d-none');
        } else {
            processingDuplicateNotice.textContent = '';
            processingDuplicateNotice.classList.add('d-none');
        }
    }

    function startUpload(filesToUpload) {
        if (!filesToUpload || filesToUpload.length === 0) {
            showToastModal('All selected files were duplicates and skipped. Select "Reprocess" for duplicates you want to upload again.', 'warning');
            setInteractionLock(false);
            resetSubmitButton();
            return;
        }

        // Show "Essays are processing" modal immediately so user can click OK and clear form (no progress overlay)
        resetSubmitButton();
        const processingStartedEl = document.getElementById('processingStartedModal');
        if (processingStartedEl) {
            showProcessingDuplicateNotice(pendingDuplicateNotice);
            if (pendingDuplicateNotice && processingStartedPrimaryMessage) {
                processingStartedPrimaryMessage.textContent = 'Some files were detected as duplicates while processing.';
            }
            bootstrap.Modal.getOrCreateInstance(processingStartedEl).show();
        }
        setInteractionLock(false);

        // Upload in background; errors surface in review or via error modal
        const formData = new FormData();
        const uploadMode = document.querySelector('input[name="upload_mode"]:checked')?.value || 'multiple';
        formData.append('upload_mode', uploadMode);
        filesToUpload.forEach(file => { formData.append('files', file); });

        fetch('{{ url_for("upload") }}', { method: 'POST', body: formData })
        .then(r => {
            if (!r.ok) {
                return r.json().then(data => {
                    throw new Error(data.error || `HTTP ${r.status}: ${r.statusText}`);
                });
            }
            return r.json();
        })
        .then(data => {
            if (!data.success) {
                showUploadErrorModal(data.error || 'Failed to start processing.');
            } else if (data.errors && data.errors.length > 0) {
                console.warn('Some files failed:', data.errors);
            }
            const duplicateCount = (data.job_ids || []).filter(j => j.is_duplicate).length;
            if (duplicateCount > 0) {
                showProcessingDuplicateNotice(`${duplicateCount} duplicate file(s) detected. Existing submissions were reused/updated.`);
                if (processingStartedPrimaryMessage) {
                    processingStartedPrimaryMessage.textContent = 'Some files were detected as duplicates while processing.';
                }
            }
        })
        .catch(error => {
            console.error('Error:', error);
            setInteractionLock(false);
            showUploadErrorModal(error.message || 'Error uploading files. Please try again.');
        });
    }

    function scanDuplicates(filesToScan) {
        const formData = new FormData();
        filesToScan.forEach(file => {
            formData.append('files', file);
        });

        return fetch('{{ url_for("scan_duplicates") }}', {
            method: 'POST',
            body: formData
        }).then(r => {
            if (!r.ok) {
                return r.json().then(data => {
                    throw new Error(data.error || `HTTP ${r.status}: ${r.statusText}`);
                });
            }
            return r.json();
        });
    }

    function showDuplicateModal(duplicateResults, onConfirm) {
        if (!duplicateModal || !duplicateList) {
            onConfirm(selectedFiles);
            return;
        }

        duplicateList.innerHTML = '';
        const ownDupes = duplicateResults.filter(r => r.is_own_duplicate).length;
        const otherDupes = duplicateResults.length - ownDupes;
        const summaryParts = [];
        if (ownDupes > 0) summaryParts.push(`${ownDupes} already uploaded by you`);
        if (otherDupes > 0) summaryParts.push(`${otherDupes} uploaded by another user`);
        duplicateSummary.textContent = `Found ${duplicateResults.length} duplicate file(s): ${summaryParts.join(', ')}.`;

        duplicateResults.forEach(result => {
            const row = document.createElement('div');
            row.className = 'list-group-item d-flex justify-content-between align-items-start';
            const badgeClass = result.is_own_duplicate ? 'bg-warning text-dark' : 'bg-danger';
            const badgeText = result.is_own_duplicate ? 'Your duplicate' : 'Other user';
            const existingName = result.existing_filename ? ` (existing: ${result.existing_filename})` : '';

            row.innerHTML = `
                <div class="me-auto">
                    <div class="fw-semibold">${result.filename}${existingName}</div>
                    <span class="badge ${badgeClass}">${badgeText}</span>
                </div>
                <div class="form-check">
                    <input class="form-check-input duplicate-keep-checkbox" type="checkbox" data-index="${result.index}" id="dup-keep-${result.index}">
                    <label class="form-check-label" for="dup-keep-${result.index}">Reprocess</label>
                </div>
            `;
            duplicateList.appendChild(row);
        });

        if (duplicateCancelBtn) {
            duplicateCancelBtn.onclick = () => {
                resetSubmitButton();
            };
        }

        if (duplicateConfirmBtn) {
            // Rebind handler in place so repeated scans don't operate on a detached node.
            duplicateConfirmBtn.onclick = function() {
                const keepIndexes = new Set(
                    Array.from(document.querySelectorAll('.duplicate-keep-checkbox:checked'))
                        .map(cb => Number(cb.dataset.index))
                );
                const duplicateIndexes = new Set(duplicateResults.map(r => r.index));
                const filesToUpload = selectedFiles.filter((file, idx) => {
                    return !duplicateIndexes.has(idx) || keepIndexes.has(idx);
                });

                duplicateModal.hide();
                if (filesToUpload.length === 0) {
                    showToastModal(
                        'All selected files are duplicates and were skipped. Check "Reprocess" for any duplicate you want to upload again.',
                        'warning'
                    );
                    pendingDuplicateNotice = `Duplicate scan found ${duplicateResults.length} duplicate file(s). All were skipped (none selected for reprocess).`;
                    resetSubmitButton();
                    return;
                }
                const reprocessCount = keepIndexes.size;
                const skippedCount = duplicateResults.length - reprocessCount;
                if (skippedCount > 0 && reprocessCount > 0) {
                    pendingDuplicateNotice = `Duplicate scan found ${duplicateResults.length} duplicate file(s): ${skippedCount} skipped, ${reprocessCount} marked for reprocess.`;
                } else if (skippedCount > 0) {
                    pendingDuplicateNotice = `Duplicate scan found ${duplicateResults.length} duplicate file(s). ${skippedCount} skipped.`;
                } else {
                    pendingDuplicateNotice = `Duplicate scan found ${duplicateResults.length} duplicate file(s). All marked for reprocess.`;
                }
                onConfirm(filesToUpload);
            };
        }

        setInteractionLock(false);
        duplicateModal.show();
    }
    
    function pollProgress() {
        return fetch('/api/batch_status')
            .then(r => r.json())
            .then(data => {
                const { total, completed, failed, pending, estimated_remaining_seconds } = data;
                
                if (total === 0) {
                    if (pollInterval) {
                        clearInterval(pollInterval);
                        pollInterval = null;
                    }
                    return;
                }
                
                // Update counts
                if (totalCount) totalCount.textContent = total;
                if (completedCount) completedCount.textContent = completed + failed;
                
                // Update progress bar
                const percent = Math.round(((completed + failed) / total) * 100);
                if (progressBar) {
                    progressBar.style.width = percent + '%';
                    progressBar.setAttribute('aria-valuenow', percent);
                    if (progressText) progressText.textContent = percent + '%';
                }
                
                // Update message
                if (pending > 0 && loadingMessage) {
                    loadingMessage.textContent = `Processing ${pending} file(s) remaining...`;
                    if (timeEstimate) {
                        timeEstimate.textContent = `Estimated time remaining: ${formatTime(estimated_remaining_seconds)}`;
                    }
                } else if (loadingMessage && (completed + failed) === total && total > 0) {
                    // All jobs completed
                    loadingMessage.textContent = `Processing complete! ${completed} succeeded, ${failed} failed.`;
                    if (timeEstimate) timeEstimate.textContent = '';
                    
                    if (pollInterval) {
                        clearInterval(pollInterval);
                        pollInterval = null;
                    }
                    
                    // Only show success notification if we haven't shown it for this batch yet
                    if (!successShownForBatch) {
                        successShownForBatch = true;
                        
                        // Show success notification immediately
                        const message = failed > 0 
                            ? `‚úÖ Processing complete! ${completed} succeeded, ${failed} failed.`
                            : `‚úÖ Successfully processed ${completed} file(s)!`;
                        
                        // Show notification
                        if (typeof showToastModal === 'function') {
                            showToastModal(message, 'success', false); // Don't auto-hide so user can see it
                        } else {
                            console.log('Notification:', message);
                        }
                    }
                    
                    // Hide loading overlay after a short delay
                    setTimeout(() => {
                        if (loadingOverlay) {
                            loadingOverlay.classList.add('d-none');
                            loadingOverlay.style.display = 'none';
                        }
                        
                        // Clear selected files
                        selectedFiles = [];
                        updateFilesList();
                        if (filesInput) filesInput.value = '';
                        
                        // Re-enable button
                        if (processBtn) {
                            processBtn.disabled = false;
                            if (btnText) btnText.textContent = 'Process Entries';
                            if (btnSpinner) btnSpinner.classList.add('d-none');
                        }
                        
                        // Clear session job tracking
                        fetch('/api/clear_jobs', { method: 'POST' })
                            .catch(err => console.error('Error clearing jobs:', err));
                        
                        // Redirect to review page after processing completes
                        setTimeout(() => {
                            window.location.href = '/review?mode=needs_review';
                        }, 1500); // Give user time to see the success message
                    }, 2000);
                }
            })
            .catch(error => {
                console.error('Error polling progress:', error);
            });
    }
    
    // Initialize: check if file input has files on page load
    // Reset selectedFiles on page load to start fresh
    selectedFiles = [];
    updateFilesList();
    
    // Ensure multiple mode is the default
    const multipleRadio = document.getElementById('multiple');
    if (multipleRadio && !multipleRadio.checked) {
        multipleRadio.checked = true;
    }
    
    if (form) {
        form.addEventListener('submit', function(e) {
            e.preventDefault();
            
            if (selectedFiles.length === 0) {
                showToastModal('Please select at least one file to upload', 'error');
                return;
            }
            
            // Disable button and show spinner
            processBtn.disabled = true;
            btnText.textContent = 'Scanning...';
            btnSpinner.classList.remove('d-none');
            setInteractionLock(true, 'Checking selected files for duplicates...');

            scanDuplicates(selectedFiles)
                .then(data => {
                    if (!data.success) {
                        throw new Error(data.error || 'Failed to scan duplicates');
                    }

                    lastScanResults = data.results || [];
                    const duplicateResults = lastScanResults.filter(r => r.is_duplicate);

                    if (data.errors && data.errors.length > 0) {
                        console.warn('Scan warnings:', data.errors);
                    }

                    if (duplicateResults.length === 0) {
                        pendingDuplicateNotice = '';
                        btnText.textContent = 'Uploading...';
                        startUpload(selectedFiles);
                        return;
                    }

                    btnText.textContent = 'Upload Selected';
                    pendingDuplicateNotice = `Duplicate scan found ${duplicateResults.length} duplicate file(s).`;
                    showDuplicateModal(duplicateResults, (filesToUpload) => {
                        btnText.textContent = 'Uploading...';
                        startUpload(filesToUpload);
                    });
                })
                .catch(error => {
                    console.error('Error scanning duplicates:', error);
                    setInteractionLock(false);
                    showToastModal('Error scanning files: ' + error.message, 'error');
                    resetSubmitButton();
                });
        });
    }
    
    // On page load: clear any session job tracking so dashboard shows empty form.
    // Processing continues in background; user gets email when done.
    fetch('/api/batch_status')
        .then(r => r.json())
        .then(data => {
            if (data.total > 0) {
                fetch('/api/clear_jobs', { method: 'POST' })
                    .catch(err => console.error('Error clearing jobs:', err));
            }
        })
        .catch(() => {});
    
    // Hide loading overlay if page loads with results (means processing completed)
    {% if session.upload_results %}
    if (loadingOverlay) {
        loadingOverlay.classList.add('d-none');
    }
    if (pollInterval) {
        clearInterval(pollInterval);
    }
    {% endif %}
});
</script>
{% endblock %}
