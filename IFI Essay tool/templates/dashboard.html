{% extends "base.html" %}

{% block title %}Dashboard - IFI Essay Gateway{% endblock %}

{% block content %}
<div class="mb-4">
    <h1 class="h2">üìù IFI Essay Gateway</h1>
    <p class="text-muted">Clearing the way so every fatherhood story is heard.</p>
    <p>Welcome to IFI Essay Gateway. This tool helps teachers organize essay entries, so more time can be spent reading students' stories about what their fathers and father‚Äëfigures mean to them. It automatically gathers basic information from the official entry forms and sorts essays by grade level, while keeping each student's words exactly as they wrote them.</p>
</div>


<div class="card">
    <div class="card-header">
        <h3 class="h5 mb-0">1Ô∏è‚É£ Upload Entry Forms</h3>
    </div>
    <div class="card-body">
        <form method="POST" action="{{ url_for('upload') }}" enctype="multipart/form-data">
            <div class="mb-3">
                <label class="form-label"><strong>üì§ Upload Mode:</strong></label>
                <div class="btn-group w-100" role="group">
                    <input type="radio" class="btn-check" name="upload_mode" id="single" value="single">
                    <label class="btn btn-outline-primary" for="single">Single Entry</label>
                    
                    <input type="radio" class="btn-check" name="upload_mode" id="multiple" value="multiple" checked>
                    <label class="btn btn-outline-primary" for="multiple">Multiple Entries</label>
                </div>
            </div>

            <div class="mb-3">
                <label for="files" class="form-label">Choose entry form(s)</label>
                <input type="file" class="form-control" id="files" name="files" 
                       accept=".png,.jpg,.jpeg,.pdf" multiple>
                <div class="form-text">Upload IFI essay contest entry form(s) (PNG, JPG, or PDF)</div>
            </div>
            
            <!-- Selected Files List -->
            <div id="selectedFilesList" class="mb-3" style="display: none;">
                <label class="form-label"><strong>Selected Files:</strong></label>
                <div id="filesList" class="list-group">
                    <!-- Files will be added here dynamically -->
                </div>
            </div>

            <button type="submit" class="btn btn-primary btn-lg" id="processBtn">
                <i class="bi bi-upload"></i> <span id="btnText">Process Entries</span>
                <span id="btnSpinner" class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
            </button>
        </form>
        
        <!-- Processing Status (Inline) -->
        <div id="processingStatus" class="alert alert-info mt-3 d-none" role="alert">
            <div class="mb-3">
                <div class="d-flex align-items-center mb-2">
                    <div id="processingSpinner" class="spinner-border spinner-border-sm me-3" role="status">
                        <span class="visually-hidden">Processing...</span>
                    </div>
                    <div id="processingIcon" class="d-none me-3" style="font-size: 1.5rem;">‚úÖ</div>
                    <strong id="processingTitle">‚è≥ Processing entries...</strong>
                </div>
                <div class="progress" style="height: 30px; background-color: #e9ecef;">
                    <div id="processingProgressBar" class="progress-bar progress-bar-striped progress-bar-animated bg-primary" 
                         role="progressbar" style="width: 5%; min-width: 50px;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                        <span id="processingProgressText" style="color: white; font-weight: 600;">0%</span>
                    </div>
                </div>
                <p class="mb-0 small mt-2" id="processingMessage">
                    <span id="processingCount">0</span> of <span id="processingTotal">0</span> entries processed
                </p>
            </div>
        </div>

        <!-- Duplicate Scan Modal -->
        <div class="modal fade" id="duplicateModal" tabindex="-1" aria-labelledby="duplicateModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="duplicateModalLabel">Duplicates Detected</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <p class="text-muted mb-3" id="duplicateSummary"></p>
                        <div class="list-group" id="duplicateList"></div>
                        <div class="form-text mt-2">
                            By default, duplicate files are skipped. Check any duplicate you want to reprocess.
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-outline-secondary" id="duplicateCancelBtn" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" id="duplicateConfirmBtn">Upload Selected</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

{% if session.upload_results %}
<div class="card">
    <div class="card-header d-flex justify-content-between align-items-center">
        <h3 class="h5 mb-0">üìä Processing Results</h3>
        <form method="POST" action="{{ url_for('clear_results') }}" style="display: inline;">
            <button type="submit" class="btn btn-sm btn-outline-secondary">
                <i class="bi bi-x-circle"></i> Dismiss
            </button>
        </form>
    </div>
    <div class="card-body">
        {% for result in session.upload_results %}
        <div class="alert alert-{{ 'success' if result.status == 'success' else 'danger' }}">
            <strong>{{ result.filename }}</strong>
            {% if result.status == 'success' %}
                <br>‚úÖ Successfully processed (ID: {{ result.submission_id }})
            {% else %}
                <br>‚ùå Error: {{ result.error }}
            {% endif %}
        </div>
        {% endfor %}
    </div>
</div>
{% endif %}

<div class="row">
    <div class="col-md-4">
        <div class="card">
            <div class="card-body text-center">
                <h3 class="h2" id="dbStatsTotal">{{ db_stats.total_count }}</h3>
                <p class="text-muted mb-0">Total Records</p>
            </div>
        </div>
    </div>
    <div class="col-md-4">
        <div class="card">
            <div class="card-body text-center">
                <h3 class="h2 text-success" id="dbStatsClean">{{ db_stats.clean_count }}</h3>
                <p class="text-muted mb-0">Clean Records</p>
            </div>
        </div>
    </div>
    <div class="col-md-4">
        <div class="card">
            <div class="card-body text-center">
                <h3 class="h2 text-warning" id="dbStatsNeedsReview">{{ db_stats.needs_review_count }}</h3>
                <p class="text-muted mb-0">Needs Review</p>
            </div>
        </div>
    </div>
</div>

<div class="mt-4 text-center text-muted small">
    <p>üí° IFI Essay Gateway is an internal intake and review assistant that helps manage thousands of student essays submitted each year for the Illinois Fatherhood Initiative's fatherhood essay contest.</p>
</div>
{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const form = document.querySelector('form[action="{{ url_for('upload') }}"]');
    const processBtn = document.getElementById('processBtn');
    const btnText = document.getElementById('btnText');
    const btnSpinner = document.getElementById('btnSpinner');
    const processingStatus = document.getElementById('processingStatus');
    const loadingMessage = document.getElementById('loadingMessage');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const completedCount = document.getElementById('completedCount');
    const totalCount = document.getElementById('totalCount');
    const timeEstimate = document.getElementById('timeEstimate');
    const filesInput = document.getElementById('files');
    const selectedFilesList = document.getElementById('selectedFilesList');
    const filesList = document.getElementById('filesList');
    const duplicateModalEl = document.getElementById('duplicateModal');
    const duplicateList = document.getElementById('duplicateList');
    const duplicateSummary = document.getElementById('duplicateSummary');
    const duplicateConfirmBtn = document.getElementById('duplicateConfirmBtn');
    const duplicateCancelBtn = document.getElementById('duplicateCancelBtn');
    const duplicateModal = duplicateModalEl ? new bootstrap.Modal(duplicateModalEl) : null;
    
    if (!filesInput) {
        console.error('File input element not found!');
    }
    if (!selectedFilesList) {
        console.error('Selected files list element not found!');
    }
    if (!filesList) {
        console.error('Files list element not found!');
    }
    
    let pollInterval = null;
    let startTime = null;
    let selectedFiles = []; // Array to store File objects
    let lastScanResults = [];
    
    // Function to hide processing status
    window.closeLoadingOverlay = function() {
        if (processingStatus) {
            processingStatus.classList.add('d-none');
        }
        
        // Clear selected files
        selectedFiles = [];
        updateFilesList();
        if (filesInput) filesInput.value = '';
        
        // Re-enable button
        resetSubmitButton();
    };
    
    // Check processing progress by polling job status
    let processingCheckCount = 0;
    function checkProcessingProgress(jobIds, totalJobs) {
        processingCheckCount++;
        
        // After 60 checks (3 minutes), assume done and refresh
        if (processingCheckCount > 60) {
            window.location.reload();
            return;
        }
        
        // Check job status via API
        fetch('{{ url_for("check_jobs_status") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ job_ids: jobIds })
        })
        .then(r => r.json())
        .then(data => {
            if (!data.success) {
                console.error('Job status check failed:', data.error);
                // Try again
                setTimeout(() => checkProcessingProgress(jobIds, totalJobs), 3000);
                return;
            }
            
            const completedCount = data.completed || 0;
            const percentage = data.percentage || 0;
            
            // Update progress UI
            const progressBar = document.getElementById('processingProgressBar');
            const progressText = document.getElementById('processingProgressText');
            const countEl = document.getElementById('processingCount');
            
            // Ensure minimum visible width (5% or actual percentage, whichever is higher)
            const displayWidth = Math.max(5, percentage);
            
            if (progressBar) {
                progressBar.style.width = displayWidth + '%';
                progressBar.setAttribute('aria-valuenow', percentage);
                if (displayWidth < 50) {
                    progressBar.style.minWidth = '50px';
                } else {
                    progressBar.style.minWidth = '0';
                }
            }
            if (progressText) progressText.textContent = percentage + '%';
            if (countEl) countEl.textContent = completedCount;
            
            // Check if all jobs are complete
            if (data.is_complete) {
                // Processing complete!
                const spinner = document.getElementById('processingSpinner');
                const icon = document.getElementById('processingIcon');
                const title = document.getElementById('processingTitle');
                const message = document.getElementById('processingMessage');
                
                if (spinner) spinner.classList.add('d-none');
                if (icon) icon.classList.remove('d-none');
                if (title) title.textContent = '‚úÖ Processing Complete!';
                if (message) message.innerHTML = `<strong>${completedCount} ${completedCount === 1 ? 'entry' : 'entries'} ready for review!</strong>`;
                
                if (progressBar) {
                    progressBar.style.width = '100%';
                    progressBar.classList.remove('progress-bar-animated', 'progress-bar-striped');
                    progressBar.classList.add('bg-success');
                }
                
                // Change alert color to success
                if (processingStatus) {
                    processingStatus.classList.remove('alert-info');
                    processingStatus.classList.add('alert-success');
                }
                
                // Auto-refresh after 2 seconds to show results
                setTimeout(() => {
                    window.location.reload();
                }, 2000);
            } else {
                // Still processing, check again in 3 seconds
                setTimeout(() => checkProcessingProgress(jobIds, totalJobs), 3000);
            }
        })
        .catch(err => {
            console.error('Error checking job progress:', err);
            // Keep checking even on error
            setTimeout(() => checkProcessingProgress(jobIds, totalJobs), 5000);
        });
    }
    
    // Function to update the selected files display
    function updateFilesList() {
        console.log('updateFilesList called. selectedFiles.length:', selectedFiles.length);
        
        if (selectedFiles.length === 0) {
            selectedFilesList.style.display = 'none';
            filesList.innerHTML = '';
            processBtn.disabled = true;
        } else {
            selectedFilesList.style.display = 'block';
            filesList.innerHTML = '';
            processBtn.disabled = false;
            
            selectedFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'list-group-item d-flex justify-content-between align-items-center';
                
                // Determine icon based on file extension
                const ext = file.name.split('.').pop().toLowerCase();
                let iconClass = 'bi-file-pdf text-danger';
                if (['png', 'jpg', 'jpeg'].includes(ext)) {
                    iconClass = 'bi-file-image text-primary';
                }
                
                fileItem.innerHTML = `
                    <div class="d-flex align-items-center">
                        <i class="bi ${iconClass} me-2"></i>
                        <span>${file.name}</span>
                        <small class="text-muted ms-2">(${(file.size / 1024).toFixed(1)} KB)</small>
                    </div>
                    <button type="button" class="btn btn-sm btn-outline-danger" onclick="removeFile(${index})">
                        <i class="bi bi-x-circle"></i> Remove
                    </button>
                `;
                filesList.appendChild(fileItem);
            });
            
            console.log('Files list updated. Displayed', selectedFiles.length, 'files');
        }
    }
    
    // Function to remove a file from the selection
    window.removeFile = function(index) {
        console.log('Removing file at index:', index);
        if (index >= 0 && index < selectedFiles.length) {
            selectedFiles.splice(index, 1);
            console.log('Remaining files:', selectedFiles.length);
            updateFilesList();
        }
    };
    
    // Handle file input change
    if (filesInput) {
        filesInput.addEventListener('change', function(e) {
            console.log('File input change event fired!');
            console.log('Event target:', e.target);
            console.log('Files:', e.target.files);
            console.log('Files length:', e.target.files ? e.target.files.length : 0);
            
            if (!e.target.files || e.target.files.length === 0) {
                console.log('No files selected or user cancelled');
                return; // User cancelled file selection
            }
            
            const newFiles = Array.from(e.target.files);
            console.log('New files array:', newFiles);
            console.log('New files count:', newFiles.length);
            
            // Check upload mode - default to 'multiple' if not found
            const uploadModeRadio = document.querySelector('input[name="upload_mode"]:checked');
            const uploadMode = uploadModeRadio ? uploadModeRadio.value : 'multiple';
            console.log('Upload mode:', uploadMode);
            
            if (uploadMode === 'single') {
                // Single mode: replace existing files with the new selection
                selectedFiles = newFiles.slice(0, 1); // Only take the first file
                console.log('Single mode: selected', selectedFiles.length, 'file');
                console.log('Selected file:', selectedFiles[0] ? selectedFiles[0].name : 'none');
            } else {
                // Multiple mode: add new files to existing selection (avoid duplicates)
                let addedCount = 0;
                newFiles.forEach((newFile, idx) => {
                    console.log(`Processing file ${idx + 1}:`, newFile.name, newFile.size, 'bytes');
                    // Check if file already exists (by name and size)
                    const exists = selectedFiles.some(f => 
                        f.name === newFile.name && 
                        f.size === newFile.size &&
                        f.lastModified === newFile.lastModified
                    );
                    if (!exists) {
                        selectedFiles.push(newFile);
                        addedCount++;
                        console.log('Added file:', newFile.name);
                    } else {
                        console.log('Skipped duplicate:', newFile.name);
                    }
                });
                console.log('Multiple mode: added', addedCount, 'new files. Total:', selectedFiles.length);
            }
            
            // Clear the file input to allow selecting the same files again if needed
            // We'll use selectedFiles array for submission, not the input
            this.value = '';
            
            // Update the display
            console.log('Calling updateFilesList with', selectedFiles.length, 'files');
            updateFilesList();
        });
        
        console.log('File input change listener attached');
    } else {
        console.error('Cannot attach file input listener - filesInput is null');
    }
    
    // Handle upload mode change
    document.querySelectorAll('input[name="upload_mode"]').forEach(radio => {
        radio.addEventListener('change', function(e) {
            const mode = e.target.value;
            
            if (mode === 'single' && selectedFiles.length > 1) {
                // Switch to single mode: keep only the first file
                selectedFiles = selectedFiles.slice(0, 1);
                
                // Update the file input
                const dataTransfer = new DataTransfer();
                if (selectedFiles.length > 0) {
                    dataTransfer.items.add(selectedFiles[0]);
                }
                filesInput.files = dataTransfer.files;
                
                updateFilesList();
            }
            // If switching to multiple mode, no need to change anything
        });
    });
    
    function formatTime(seconds) {
        if (seconds < 60) {
            return `${Math.ceil(seconds)} seconds`;
        } else {
            const mins = Math.floor(seconds / 60);
            const secs = Math.ceil(seconds % 60);
            return `${mins}m ${secs}s`;
        }
    }
    
    // Track if we've already shown success for current batch
    let successShownForBatch = false;

    function resetSubmitButton() {
        if (processBtn) processBtn.disabled = false;
        if (btnText) btnText.textContent = 'Process Entries';
        if (btnSpinner) btnSpinner.classList.add('d-none');
    }

    function startUpload(filesToUpload) {
        if (!filesToUpload || filesToUpload.length === 0) {
            showToastModal('No files selected to upload.', 'warning');
            resetSubmitButton();
            return;
        }

        // Show loading overlay
        processingStatus.classList.remove('d-none');
        startTime = Date.now();

        // Create FormData with selected files
        const formData = new FormData();
        const uploadMode = document.querySelector('input[name="upload_mode"]:checked')?.value || 'multiple';
        formData.append('upload_mode', uploadMode);

        filesToUpload.forEach(file => {
            formData.append('files', file);
        });

        console.log(`Uploading ${filesToUpload.length} file(s) in ${uploadMode} mode`);

        fetch('{{ url_for("upload") }}', {
            method: 'POST',
            body: formData
        })
        .then(r => {
            if (!r.ok) {
                return r.json().then(data => {
                    throw new Error(data.error || `HTTP ${r.status}: ${r.statusText}`);
                });
            }
            return r.json();
        })
        .then(data => {
            if (data.success) {
                // Check for duplicate files (in case user forced reprocess)
                const duplicateFiles = data.job_ids?.filter(job => job.is_duplicate) || [];
                const ownDuplicates = duplicateFiles.filter(job => job.is_own_duplicate);
                const otherDuplicates = duplicateFiles.filter(job => !job.is_own_duplicate);

                if (duplicateFiles.length > 0) {
                    let duplicateMessage = '';
                    if (ownDuplicates.length > 0 && otherDuplicates.length > 0) {
                        duplicateMessage = `‚ö†Ô∏è ${ownDuplicates.length} file(s) you already uploaded and ${otherDuplicates.length} duplicate file(s) detected. They will update existing records.`;
                    } else if (ownDuplicates.length > 0) {
                        duplicateMessage = `‚ö†Ô∏è ${ownDuplicates.length} duplicate file(s) detected. You already uploaded ${ownDuplicates.length === 1 ? 'this essay' : 'these essays'}. It will update the existing record(s).`;
                    } else if (otherDuplicates.length > 0) {
                        duplicateMessage = `‚ö†Ô∏è ${otherDuplicates.length} duplicate file(s) detected. This essay was already uploaded by someone else. It will update the existing record(s).`;
                    }

                    if (duplicateMessage && typeof showToastModal === 'function') {
                        showToastModal(duplicateMessage, 'warning', false);
                    } else if (duplicateMessage) {
                        console.warn(duplicateMessage);
                    }
                }

                if (totalCount) totalCount.textContent = data.total;
                if (completedCount) completedCount.textContent = '0';
                if (loadingMessage) loadingMessage.textContent = `Processing ${data.total} file(s)...`;
                if (progressBar) {
                    progressBar.style.width = '0%';
                    if (progressText) progressText.textContent = '0%';
                }

                if (data.errors && data.errors.length > 0) {
                    console.warn('Some files failed to enqueue:', data.errors);
                }

                // Set total count and extract job IDs
                const totalJobs = data.total || 0;
                const jobIds = (data.job_ids || []).map(j => j.job_id).filter(id => id);
                const totalEl = document.getElementById('processingTotal');
                if (totalEl) totalEl.textContent = totalJobs;
                
                // Start polling for progress
                if (totalJobs > 0 && jobIds.length > 0) {
                    checkProcessingProgress(jobIds, totalJobs);
                }
            } else {
                showToastModal('Error: ' + (data.error || 'Failed to start processing'), 'error');
                processingStatus.classList.add('d-none');
                resetSubmitButton();
            }
        })
        .catch(error => {
            console.error('Error:', error);
            showToastModal('Error uploading files: ' + error.message, 'error');
            processingStatus.classList.add('d-none');
            resetSubmitButton();
        });
    }

    function scanDuplicates(filesToScan) {
        const formData = new FormData();
        filesToScan.forEach(file => {
            formData.append('files', file);
        });

        return fetch('{{ url_for("scan_duplicates") }}', {
            method: 'POST',
            body: formData
        }).then(r => {
            if (!r.ok) {
                return r.json().then(data => {
                    throw new Error(data.error || `HTTP ${r.status}: ${r.statusText}`);
                });
            }
            return r.json();
        });
    }

    function showDuplicateModal(duplicateResults, onConfirm) {
        if (!duplicateModal || !duplicateList) {
            onConfirm(selectedFiles);
            return;
        }

        duplicateList.innerHTML = '';
        const ownDupes = duplicateResults.filter(r => r.is_own_duplicate).length;
        const otherDupes = duplicateResults.length - ownDupes;
        const summaryParts = [];
        if (ownDupes > 0) summaryParts.push(`${ownDupes} already uploaded by you`);
        if (otherDupes > 0) summaryParts.push(`${otherDupes} uploaded by another user`);
        duplicateSummary.textContent = `Found ${duplicateResults.length} duplicate file(s): ${summaryParts.join(', ')}.`;

        duplicateResults.forEach(result => {
            const row = document.createElement('div');
            row.className = 'list-group-item d-flex justify-content-between align-items-start';
            const badgeClass = result.is_own_duplicate ? 'bg-warning text-dark' : 'bg-danger';
            const badgeText = result.is_own_duplicate ? 'Your duplicate' : 'Other user';
            const existingName = result.existing_filename ? ` (existing: ${result.existing_filename})` : '';

            row.innerHTML = `
                <div class="me-auto">
                    <div class="fw-semibold">${result.filename}${existingName}</div>
                    <span class="badge ${badgeClass}">${badgeText}</span>
                </div>
                <div class="form-check">
                    <input class="form-check-input duplicate-keep-checkbox" type="checkbox" data-index="${result.index}" id="dup-keep-${result.index}">
                    <label class="form-check-label" for="dup-keep-${result.index}">Reprocess</label>
                </div>
            `;
            duplicateList.appendChild(row);
        });

        if (duplicateCancelBtn) {
            duplicateCancelBtn.onclick = () => {
                resetSubmitButton();
            };
        }

        if (duplicateConfirmBtn) {
            const newConfirmBtn = duplicateConfirmBtn.cloneNode(true);
            duplicateConfirmBtn.parentNode.replaceChild(newConfirmBtn, duplicateConfirmBtn);

            newConfirmBtn.addEventListener('click', function() {
                const keepIndexes = new Set(
                    Array.from(document.querySelectorAll('.duplicate-keep-checkbox:checked'))
                        .map(cb => Number(cb.dataset.index))
                );
                const duplicateIndexes = new Set(duplicateResults.map(r => r.index));
                const filesToUpload = selectedFiles.filter((file, idx) => {
                    return !duplicateIndexes.has(idx) || keepIndexes.has(idx);
                });

                duplicateModal.hide();
                onConfirm(filesToUpload);
            });
        }

        duplicateModal.show();
    }
    
    function pollProgress() {
        return fetch('/api/batch_status')
            .then(r => r.json())
            .then(data => {
                const { total, completed, failed, pending, estimated_remaining_seconds } = data;
                
                if (total === 0) {
                    if (pollInterval) {
                        clearInterval(pollInterval);
                        pollInterval = null;
                    }
                    return;
                }
                
                // Update counts
                if (totalCount) totalCount.textContent = total;
                if (completedCount) completedCount.textContent = completed + failed;
                
                // Update progress bar
                const percent = Math.round(((completed + failed) / total) * 100);
                if (progressBar) {
                    progressBar.style.width = percent + '%';
                    progressBar.setAttribute('aria-valuenow', percent);
                    if (progressText) progressText.textContent = percent + '%';
                }
                
                // Update message
                if (pending > 0 && loadingMessage) {
                    loadingMessage.textContent = `Processing ${pending} file(s) remaining...`;
                    if (timeEstimate) {
                        timeEstimate.textContent = `Estimated time remaining: ${formatTime(estimated_remaining_seconds)}`;
                    }
                } else if (loadingMessage && (completed + failed) === total && total > 0) {
                    // All jobs completed
                    loadingMessage.textContent = `Processing complete! ${completed} succeeded, ${failed} failed.`;
                    if (timeEstimate) timeEstimate.textContent = '';
                    
                    if (pollInterval) {
                        clearInterval(pollInterval);
                        pollInterval = null;
                    }
                    
                    // Only show success notification if we haven't shown it for this batch yet
                    if (!successShownForBatch) {
                        successShownForBatch = true;
                        
                        // No success modal - users will receive email notification instead
                        console.log(`Processing complete: ${completed} succeeded, ${failed} failed.`);
                    }
                    
                    // Hide processing status after a short delay
                    setTimeout(() => {
                        if (processingStatus) {
                            processingStatus.classList.add('d-none');
                        }
                        
                        // Clear selected files
                        selectedFiles = [];
                        updateFilesList();
                        if (filesInput) filesInput.value = '';
                        
                        // Re-enable button
                        if (processBtn) {
                            processBtn.disabled = false;
                            if (btnText) btnText.textContent = 'Process Entries';
                            if (btnSpinner) btnSpinner.classList.add('d-none');
                        }
                        
                        // Clear session job tracking
                        fetch('/api/clear_jobs', { method: 'POST' })
                            .catch(err => console.error('Error clearing jobs:', err));
                        
                        // Redirect to review page after processing completes
                        setTimeout(() => {
                            window.location.href = '/review?mode=needs_review';
                        }, 1500); // Give user time to see the success message
                    }, 2000);
                }
            })
            .catch(error => {
                console.error('Error polling progress:', error);
            });
    }
    
    // Initialize: check if file input has files on page load
    // Reset selectedFiles on page load to start fresh
    selectedFiles = [];
    updateFilesList();
    
    // Ensure multiple mode is the default
    const multipleRadio = document.getElementById('multiple');
    if (multipleRadio && !multipleRadio.checked) {
        multipleRadio.checked = true;
    }
    
    if (form) {
        form.addEventListener('submit', function(e) {
            e.preventDefault();
            
            if (selectedFiles.length === 0) {
                showToastModal('Please select at least one file to upload', 'error');
                return;
            }
            
            // Disable button and show spinner
            processBtn.disabled = true;
            btnText.textContent = 'Scanning...';
            btnSpinner.classList.remove('d-none');

            scanDuplicates(selectedFiles)
                .then(data => {
                    if (!data.success) {
                        throw new Error(data.error || 'Failed to scan duplicates');
                    }

                    lastScanResults = data.results || [];
                    const duplicateResults = lastScanResults.filter(r => r.is_duplicate);

                    if (data.errors && data.errors.length > 0) {
                        console.warn('Scan warnings:', data.errors);
                    }

                    if (duplicateResults.length === 0) {
                        btnText.textContent = 'Uploading...';
                        startUpload(selectedFiles);
                        return;
                    }

                    btnText.textContent = 'Upload Selected';
                    showDuplicateModal(duplicateResults, (filesToUpload) => {
                        btnText.textContent = 'Uploading...';
                        startUpload(filesToUpload);
                    });
                })
                .catch(error => {
                    console.error('Error scanning duplicates:', error);
                    showToastModal('Error scanning files: ' + error.message, 'error');
                    resetSubmitButton();
                });
        });
    }
    
    // Clear old completed jobs on page load to prevent showing old success modals
    fetch('/api/batch_status')
        .then(r => r.json())
        .then(data => {
            const { total, pending, in_progress, completed, failed } = data;
            // If there are jobs but they're all completed, clear them immediately
            if (total > 0 && (completed + failed) === total && (pending === 0 && in_progress === 0)) {
                fetch('/api/clear_jobs', { method: 'POST' })
                    .catch(err => console.error('Error clearing old jobs:', err));
            } else if (total > 0 && (pending > 0 || in_progress > 0)) {
                // Only start polling if there are active jobs
                pollProgress();
                pollInterval = setInterval(pollProgress, 2000);
            }
        })
        .catch(err => {
            // If error, don't start polling
            console.log('No active jobs to poll');
        });
    
    // Hide processing status if page loads with results (means processing completed)
    {% if session.upload_results %}
    if (processingStatus) {
        processingStatus.classList.add('d-none');
    }
    if (pollInterval) {
        clearInterval(pollInterval);
    }
    {% endif %}
});
</script>
{% endblock %}
